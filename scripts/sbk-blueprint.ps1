param(
  [Parameter(ValueFromRemainingArguments = $true)][string[]]$CommandArgs
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

$repoRoot = (Resolve-Path (Join-Path $PSScriptRoot "..")).Path
. (Join-Path $PSScriptRoot "common\\sbk-runtime.ps1")

function Show-Usage {
  Write-Host "sbk blueprint <operation> [args]"
  Write-Host ""
  Write-Host "Operations:"
  Write-Host "  list"
  Write-Host "  apply --name <blueprint> [--target-repo-root <path>] [--project-name <name>] [--adapter <name>] [--force] [--allow-beta]"
  Write-Host "  verify [--name <blueprint>] [--target-repo-root <path>]"
}

function Resolve-TargetRepoRoot {
  param(
    [Parameter(Mandatory = $true)][string]$Path
  )

  $resolved = Resolve-SbkPath -BasePath $repoRoot -Path $Path
  if (-not (Test-Path $resolved -PathType Container)) {
    throw "target repository path does not exist or is not a directory: $resolved"
  }
  return (Resolve-Path -LiteralPath $resolved).Path
}

function Get-BlueprintRegistry {
  $path = Join-Path $repoRoot "config\\blueprints\\registry.json"
  $registry = Read-SbkJsonFile -Path $path
  if ($null -eq $registry) {
    throw "blueprint registry missing: $path"
  }
  return [PSCustomObject]@{
    path = $path
    value = $registry
  }
}

function Get-BlueprintManifest {
  param(
    [Parameter(Mandatory = $true)]$Registry,
    [Parameter(Mandatory = $true)][string]$Name
  )

  $entry = @($Registry.value.packs | Where-Object { [string]$_.name -eq $Name } | Select-Object -First 1)
  if ($entry.Count -eq 0) {
    $known = @($Registry.value.packs | ForEach-Object { [string]$_.name } | Sort-Object)
    throw ("unknown blueprint pack '{0}'. available: {1}" -f $Name, ($known -join ", "))
  }

  $manifestPathRaw = [string]$entry[0].manifestPath
  if ([string]::IsNullOrWhiteSpace($manifestPathRaw)) {
    throw "blueprint '$Name' manifest path is missing in registry."
  }
  $manifestPath = Resolve-SbkPath -BasePath $repoRoot -Path $manifestPathRaw
  $manifest = Read-SbkJsonFile -Path $manifestPath
  if ($null -eq $manifest) {
    throw "blueprint '$Name' manifest file missing or invalid: $manifestPath"
  }

  return [PSCustomObject]@{
    entry = $entry[0]
    path = $manifestPath
    value = $manifest
  }
}

function Invoke-PackValidation {
  param(
    [Parameter(Mandatory = $true)]$Manifest,
    [Parameter(Mandatory = $true)][string]$TargetRepoRoot
  )

  $scriptRelative = [string](Get-SbkPropertyValue -Object $Manifest.value -Name "postValidateScript")
  if ([string]::IsNullOrWhiteSpace($scriptRelative)) {
    return
  }

  $packDir = Split-Path $Manifest.path -Parent
  $scriptPath = Join-Path $packDir ($scriptRelative -replace "/", "\")
  if (-not (Test-Path $scriptPath -PathType Leaf)) {
    throw "post validation script missing: $scriptPath"
  }

  $shell = "powershell"
  if (-not (Get-Command powershell -ErrorAction SilentlyContinue)) {
    $shell = "pwsh"
  }

  & $shell -ExecutionPolicy Bypass -File $scriptPath -TargetRepoRoot $TargetRepoRoot
  if (($LASTEXITCODE -is [int]) -and $LASTEXITCODE -ne 0) {
    throw "blueprint post-validation failed: $scriptPath"
  }
}

function ConvertTo-TemplateContent {
  param(
    [Parameter(Mandatory = $true)][string]$TemplateId
  )

  $id = $TemplateId.Trim()
  switch -Exact ($id) {
    "root-readme" {
      return @"
# {{PROJECT_NAME}}

Generated by SBK blueprint `{{BLUEPRINT_NAME}}` (version `{{BLUEPRINT_VERSION}}`, channel `{{BLUEPRINT_CHANNEL}}`).

## Baseline Scope
- CI and quality gate wiring
- Security policy baseline
- Operational runbook skeleton
- Architecture capture templates

## Active Adapter
{{ADAPTER}}
"@
    }
    "ci-workflow" {
      return @"
name: CI

on:
  push:
    branches: ["main"]
  pull_request:

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
      - run: npm ci
      - run: npm run verify:ci
"@
    }
    "verify-map" {
      return @"
{
  "generatedBy": "sbk blueprint apply",
  "blueprint": "{{BLUEPRINT_NAME}}",
  "version": "{{BLUEPRINT_VERSION}}",
  "channel": "{{BLUEPRINT_CHANNEL}}",
  "commands": {
    "fast": "npm run verify:fast",
    "full": "npm run verify",
    "ci": "npm run verify:ci",
    "policy": "npm run workflow:policy",
    "doctor": "npm run workflow:doctor"
  }
}
"@
    }
    "security-policy" {
      return @"
# Security Policy

## Scope
This repository follows SBK security baseline and workflow policy gates.

## Reporting
- Use private disclosure channels for vulnerabilities.
- Include reproduction steps, impact, and affected versions.

## Runtime Hygiene
- Keep secrets out of durable artifacts.
- Run `npm run secret:scan:diff` before merge.
"@
    }
    "runbook-ops" {
      return @"
# Operations Runbook

## Service
`{{PROJECT_NAME}}` (`{{BLUEPRINT_NAME}}`)

## Health Signals
- Build and verify success rate
- Workflow policy gate status
- Lead time and rework trend

## Incident Triage
1. Run `npm run workflow:doctor`.
2. Run `npm run verify:ci`.
3. Attach `.metrics/` reports to incident ticket.
"@
    }
    "release-readiness" {
      return @"
# Release Readiness Checklist

- [ ] `npm run verify:ci` passes
- [ ] policy/docs/indicator gates pass
- [ ] migration notes documented
- [ ] rollback plan documented
- [ ] on-call owner assigned
"@
    }
    "architecture-adr" {
      return @"
# ADR-0001: Initial Architecture Baseline

## Context
Generated from blueprint `{{BLUEPRINT_NAME}}`.

## Decision
Adopt SBK policy-aligned workflow baseline from day zero.

## Consequences
- Strong governance signals early.
- Higher initial setup, lower long-run drift.
"@
    }
    "architecture-boundaries" {
      return @"
# Service Boundaries

## Domain Segments
- Public API / interface
- Application orchestration
- Infrastructure adapters

## Boundary Rules
- Keep side effects isolated behind adapter interfaces.
- Ensure each boundary has test ownership.
"@
    }
    "architecture-dependencies" {
      return @"
# Dependency Contracts

## Runtime Dependencies
- Enumerate external services and APIs.

## Internal Contracts
- Define module-level contracts and breakage policy.

## Upgrade Policy
- Track semver constraints and compatibility checks.
"@
    }
    "api-openapi-contract" {
      return @"
# API Contract Baseline

## Endpoint Inventory
- `GET /health` endpoint
- `POST /v1/...` endpoint

## Compatibility Policy
- Non-breaking changes only in minor releases.
- Breaking changes require migration guide and version bump.
"@
    }
    "worker-job-contracts" {
      return @"
# Worker Job Contracts

## Queues
- Primary queue definition
- Retry queue definition

## Job Envelope
- id
- attempt
- payload
- trace metadata

## Reliability Policy
- retry with bounded exponential backoff
- dead-letter routing for terminal failures
"@
    }
    "cli-command-contract" {
      return @"
# CLI Command Contract

## Global Flags
- `--help` flag
- `--verbose` flag
- `--output json|text` flag

## Command Stability
- Backward compatible command names.
- Flag renames require deprecation window.
"@
    }
    "monorepo-topology" {
      return @"
# Monorepo Topology

## Workspace Layout
- `apps/` workspace
- `packages/` workspace
- `tools/` workspace

## Ownership
- each workspace declares owner and verification scope.

## Change Policy
- cross-workspace changes require explicit rollout notes.
"@
    }
    "pnpm-workspace" {
      return @"
packages:
  - "apps/*"
  - "packages/*"
  - "tools/*"
"@
    }
    "openspec-bootstrap-proposal" {
      return @"
## Why

Bootstrap baseline generated from blueprint `{{BLUEPRINT_NAME}}`.

## What Changes

- Establish initial workflow baseline artifacts.
- Capture architecture and operational contracts.
"@
    }
    default {
      throw "unknown template id: $id"
    }
  }
}

function Render-Template {
  param(
    [Parameter(Mandatory = $true)][string]$Template,
    [Parameter(Mandatory = $true)][hashtable]$Tokens
  )

  $rendered = $Template
  foreach ($key in $Tokens.Keys) {
    $rendered = $rendered.Replace("{{" + $key + "}}", [string]$Tokens[$key])
  }
  return $rendered
}

function Write-BlueprintFile {
  param(
    [Parameter(Mandatory = $true)][string]$TargetRepoRoot,
    [Parameter(Mandatory = $true)][string]$RelativePath,
    [Parameter(Mandatory = $true)][string]$Content,
    [Parameter(Mandatory = $true)][bool]$Overwrite
  )

  $normalizedRelative = ($RelativePath -replace "/", "\").TrimStart("\")
  $rootFull = [System.IO.Path]::GetFullPath($TargetRepoRoot)
  $destination = [System.IO.Path]::GetFullPath((Join-Path $rootFull $normalizedRelative))

  if (-not $destination.StartsWith($rootFull, [System.StringComparison]::OrdinalIgnoreCase)) {
    throw "unsafe template target outside repository root: $RelativePath"
  }

  $destinationDir = Split-Path -Path $destination -Parent
  if (-not (Test-Path $destinationDir)) {
    New-Item -ItemType Directory -Path $destinationDir -Force | Out-Null
  }

  if (Test-Path $destination) {
    if (-not $Overwrite) {
      throw "target file already exists (use --force to overwrite): $RelativePath"
    }
    Set-Content -Path $destination -Value $Content -Encoding UTF8
    return "updated"
  }

  Set-Content -Path $destination -Value $Content -Encoding UTF8
  return "created"
}

function Write-BlueprintReport {
  param(
    [Parameter(Mandatory = $true)][string]$TargetRepoRoot,
    [Parameter(Mandatory = $true)]$Payload
  )

  $metricsDir = Join-Path $TargetRepoRoot ".metrics"
  if (-not (Test-Path $metricsDir)) {
    New-Item -ItemType Directory -Path $metricsDir -Force | Out-Null
  }
  $reportPath = Join-Path $metricsDir "blueprint-verify.json"
  Set-Content -Path $reportPath -Value ($Payload | ConvertTo-Json -Depth 20) -Encoding UTF8
}

if ($null -eq $CommandArgs -or $CommandArgs.Count -eq 0) {
  Show-Usage
  exit 0
}

$operation = [string]$CommandArgs[0]
$rest = @()
if ($CommandArgs.Count -gt 1) {
  $rest = @($CommandArgs[1..($CommandArgs.Count - 1)])
}

$registry = Get-BlueprintRegistry

switch ($operation.ToLowerInvariant()) {
  "list" {
    $packs = @($registry.value.packs | Sort-Object { [string]$_.name })
    Write-Host "available blueprints"
    foreach ($pack in $packs) {
      $manifest = Get-BlueprintManifest -Registry $registry -Name ([string]$pack.name)
      $adapters = @((Get-SbkPropertyValue -Object $manifest.value -Name "supportedAdapters") | ForEach-Object { [string]$_ })
      Write-Host ("- {0} v{1} channel={2} adapters={3}" -f $pack.name, $pack.version, $pack.channel, ($adapters -join ","))
    }
    break
  }
  "apply" {
    $name = ""
    $targetRepoRootRaw = "."
    $projectName = ""
    $adapter = ""
    $force = $false
    $allowBeta = $false

    for ($i = 0; $i -lt $rest.Count; $i++) {
      $token = [string]$rest[$i]
      switch ($token) {
        "--name" {
          if (($i + 1) -lt $rest.Count) { $name = [string]$rest[$i + 1]; $i++ }
          continue
        }
        "--target-repo-root" {
          if (($i + 1) -lt $rest.Count) { $targetRepoRootRaw = [string]$rest[$i + 1]; $i++ }
          continue
        }
        "--project-name" {
          if (($i + 1) -lt $rest.Count) { $projectName = [string]$rest[$i + 1]; $i++ }
          continue
        }
        "--adapter" {
          if (($i + 1) -lt $rest.Count) { $adapter = [string]$rest[$i + 1]; $i++ }
          continue
        }
        "--force" {
          $force = $true
          continue
        }
        "--allow-beta" {
          $allowBeta = $true
          continue
        }
      }
    }

    if ([string]::IsNullOrWhiteSpace($name)) {
      throw "blueprint apply requires --name <blueprint>"
    }

    $manifest = Get-BlueprintManifest -Registry $registry -Name $name
    $channel = [string](Get-SbkPropertyValue -Object $manifest.value -Name "channel")
    if ($channel.Equals("beta", [System.StringComparison]::OrdinalIgnoreCase) -and -not $allowBeta) {
      throw "blueprint '$name' is beta. re-run with --allow-beta."
    }

    $targetRepoRoot = Resolve-TargetRepoRoot -Path $targetRepoRootRaw
    $lockPath = Join-Path $targetRepoRoot ".sbk\\blueprint.lock.json"
    if ((Test-Path $lockPath) -and -not $force) {
      throw "blueprint lock already exists at target. use --force to re-apply."
    }

    if ([string]::IsNullOrWhiteSpace($projectName)) {
      $projectName = Split-Path $targetRepoRoot -Leaf
    }

    if ([string]::IsNullOrWhiteSpace($adapter)) {
      $runtime = Get-SbkRuntimeContext -SbkRoot $repoRoot -TargetRepoRoot $targetRepoRoot
      $adapter = [string]$runtime.adapter
    }

    $supportedAdapters = @((Get-SbkPropertyValue -Object $manifest.value -Name "supportedAdapters") | ForEach-Object { [string]$_ })
    if ($supportedAdapters.Count -gt 0 -and -not ($supportedAdapters -contains $adapter)) {
      throw ("blueprint '{0}' does not support adapter '{1}'. supported: {2}" -f $name, $adapter, ($supportedAdapters -join ", "))
    }

    $tokens = @{
      "PROJECT_NAME" = $projectName
      "BLUEPRINT_NAME" = [string](Get-SbkPropertyValue -Object $manifest.value -Name "name")
      "BLUEPRINT_VERSION" = [string](Get-SbkPropertyValue -Object $manifest.value -Name "version")
      "BLUEPRINT_CHANNEL" = [string](Get-SbkPropertyValue -Object $manifest.value -Name "channel")
      "ADAPTER" = $adapter
    }

    $stats = [ordered]@{
      created = 0
      updated = 0
      rendered = 0
    }

    $templates = @((Get-SbkPropertyValue -Object $manifest.value -Name "templates"))
    foreach ($template in $templates) {
      $templateId = [string](Get-SbkPropertyValue -Object $template -Name "templateId")
      $targetPath = [string](Get-SbkPropertyValue -Object $template -Name "target")
      if ([string]::IsNullOrWhiteSpace($templateId) -or [string]::IsNullOrWhiteSpace($targetPath)) {
        throw "invalid template entry in manifest '$($manifest.path)'"
      }

      $rawContent = ConvertTo-TemplateContent -TemplateId $templateId
      $rendered = Render-Template -Template $rawContent -Tokens $tokens
      $result = Write-BlueprintFile `
        -TargetRepoRoot $targetRepoRoot `
        -RelativePath $targetPath `
        -Content $rendered `
        -Overwrite $force
      if ($result -eq "created") {
        $stats.created++
      } else {
        $stats.updated++
      }
      $stats.rendered++
    }

    $lockPayload = [ordered]@{
      generatedAt = [DateTimeOffset]::UtcNow.ToString("o")
      name = [string](Get-SbkPropertyValue -Object $manifest.value -Name "name")
      version = [string](Get-SbkPropertyValue -Object $manifest.value -Name "version")
      channel = [string](Get-SbkPropertyValue -Object $manifest.value -Name "channel")
      adapter = $adapter
      projectName = $projectName
      requiredArtifacts = @((Get-SbkPropertyValue -Object $manifest.value -Name "requiredArtifacts") | ForEach-Object { [string]$_ })
    }
    $lockJson = $lockPayload | ConvertTo-Json -Depth 20
    Write-BlueprintFile -TargetRepoRoot $targetRepoRoot -RelativePath ".sbk/blueprint.lock.json" -Content $lockJson -Overwrite $true | Out-Null

    Invoke-PackValidation -Manifest $manifest -TargetRepoRoot $targetRepoRoot

    Write-Host ("[blueprint] apply name={0} version={1} channel={2} target={3}" -f $lockPayload.name, $lockPayload.version, $lockPayload.channel, $targetRepoRoot)
    Write-Host ("[blueprint] adapter={0} rendered={1} created={2} updated={3}" -f $adapter, $stats.rendered, $stats.created, $stats.updated)
    break
  }
  "verify" {
    $name = ""
    $targetRepoRootRaw = "."

    for ($i = 0; $i -lt $rest.Count; $i++) {
      $token = [string]$rest[$i]
      if ($token -eq "--name" -and ($i + 1) -lt $rest.Count) {
        $name = [string]$rest[$i + 1]
        $i++
        continue
      }
      if ($token -eq "--target-repo-root" -and ($i + 1) -lt $rest.Count) {
        $targetRepoRootRaw = [string]$rest[$i + 1]
        $i++
        continue
      }
    }

    $targetRepoRoot = Resolve-TargetRepoRoot -Path $targetRepoRootRaw
    if ([string]::IsNullOrWhiteSpace($name)) {
      $lockPath = Join-Path $targetRepoRoot ".sbk\\blueprint.lock.json"
      $lock = Read-SbkJsonFile -Path $lockPath
      if ($null -eq $lock) {
        throw "no blueprint lock found. pass --name or run blueprint apply first."
      }
      $name = [string](Get-SbkPropertyValue -Object $lock -Name "name")
    }

    $manifest = Get-BlueprintManifest -Registry $registry -Name $name
    $requiredArtifacts = @((Get-SbkPropertyValue -Object $manifest.value -Name "requiredArtifacts") | ForEach-Object { [string]$_ })
    $missing = @()
    foreach ($relative in $requiredArtifacts) {
      $path = Join-Path $targetRepoRoot ($relative -replace "/", "\")
      if (-not (Test-Path $path)) {
        $missing += $relative
      }
    }

    $payload = [ordered]@{
      generatedAt = [DateTimeOffset]::UtcNow.ToString("o")
      name = [string](Get-SbkPropertyValue -Object $manifest.value -Name "name")
      version = [string](Get-SbkPropertyValue -Object $manifest.value -Name "version")
      channel = [string](Get-SbkPropertyValue -Object $manifest.value -Name "channel")
      targetRepoRoot = $targetRepoRoot
      requiredArtifacts = $requiredArtifacts
      missingArtifacts = $missing
      passed = ($missing.Count -eq 0)
      remediation = if ($missing.Count -eq 0) {
        "none"
      } else {
        "Run `sbk blueprint apply --name $name --target-repo-root `"$targetRepoRoot`"` (or restore missing files) and re-run verify."
      }
    }

    Write-BlueprintReport -TargetRepoRoot $targetRepoRoot -Payload $payload
    if ($missing.Count -eq 0) {
      Invoke-PackValidation -Manifest $manifest -TargetRepoRoot $targetRepoRoot
      Write-Host ("[blueprint] verify passed name={0} required={1}" -f $name, $requiredArtifacts.Count)
      break
    }

    Write-Host ("[blueprint] verify failed name={0} missing={1}" -f $name, ($missing -join ", "))
    throw "blueprint verify failed: missing required artifacts"
  }
  default {
    throw "unknown blueprint operation: $operation"
  }
}
