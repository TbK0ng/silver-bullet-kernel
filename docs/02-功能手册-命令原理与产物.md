# 功能手册：命令、原理与产物

本手册按“你实际会怎么用”来组织，不按代码目录组织。  
每个功能都回答四个问题：

1. 它解决什么问题。
2. 为什么这样设计。
3. 怎么用。
4. 产物和失败处理是什么。

说明：文中 `.metrics/*` 为命令执行后生成的运行报告；未执行对应命令前，这些文件可能不存在。

## 1. 验证主链路（最重要）

## `npm run verify:fast`

- 解决问题：快速确认当前改动是否违反基本质量和流程约束。
- 为什么这样设计：把最常见、最便宜的检查前置，减少返工。
- 执行内容：
  - `workflow-policy-gate.ps1 -Mode local`
  - `workflow-docs-sync-gate.ps1 -Mode local`（启用时）
  - adapter 的 `verify.fast` 命令矩阵（默认 node-ts: lint + typecheck）
- 产物：
  - 追加遥测到 `.metrics/verify-runs.jsonl`
- 适用时机：每次小改后都可以跑。

## `npm run verify`

- 解决问题：在本地给出完整可交付信号。
- 为什么这样设计：提交前必须覆盖 lint/type/test/build，避免“本地没问题但 CI 才爆”。
- 执行内容：
  - policy gate（local）
  - docs sync gate（local，启用时）
  - adapter 的 `verify.full` 命令矩阵（默认 node-ts: lint/typecheck/test/build）
- 产物：
  - 追加遥测到 `.metrics/verify-runs.jsonl`
- 适用时机：提交前、合并前。

## `npm run verify:ci`

- 解决问题：本地复现 CI 治理逻辑。
- 为什么这样设计：让 CI 失败可在本地提前复现。
- 额外检查：
  - policy gate（ci 模式）
  - docs sync gate（ci，启用时）
  - adapter 的 `verify.ci` 命令矩阵（默认 node-ts 含 e2e）
  - OpenSpec strict validate
  - metrics collect
  - indicator gate
- 产物：
  - `.metrics/verify-runs-ci.jsonl`
  - `.metrics/workflow-metrics-latest.json`
  - `.metrics/workflow-indicator-gate.md`
  - `.metrics/workflow-indicator-gate.json`

## 2. 有界修复循环（可重入执行）

## `npm run verify:loop -- -Profile fast -MaxAttempts 2`

- 解决问题：失败反复发生时，避免无结构乱试。
- 为什么这样设计：失败时自动附带诊断证据，便于稳定定位根因。
- 行为：
  - 在 `fast` 或 `full` 模式下尝试验证。
  - 每次失败后自动运行诊断：
    - `workflow-doctor`（静默）
    - `workflow-policy-gate`（静默）
    - `git status`
- 产物：
  - `.metrics/verify-fix-loop.jsonl`
- 失败出口：
  - 超过最大尝试次数后非零退出。

## 3. 治理门禁（Policy Gate）

## `npm run workflow:policy`

- 解决问题：让流程规则可执行，而不是口头约定。
- 为什么这样设计：流程一旦靠自觉，团队规模一上来就会漂移。
- 关键检查（摘核心）：
  - 实现改动必须映射 OpenSpec 变更包。
  - active change 必须包含 proposal/design/tasks/spec delta。
  - `tasks.md` 必须有 `Task Evidence` 表，且列完整、行非空、粒度可控。
  - 分支名必须符合 `sbk-<owner>-<change>`。
  - 分支 `<change>` 必须匹配 active change。
  - 本地实现必须来自 linked worktree。
  - owner 作用域会话证据必须存在且含披露标记。
  - CI 分支增量必须可解析、不能退化为 base=head。
  - 安全策略：
    - denylist 敏感路径禁止改动
    - 持久化产物（`.trellis/workspace/`、`openspec/`、`docs/`）做 secret 模式扫描
  - 调度代理边界：
    - dispatcher frontmatter 禁止暴露写能力工具（如 `Write/Edit/MultiEdit`）
- 产物：
  - `.metrics/workflow-policy-gate.md`
  - `.metrics/workflow-policy-gate.json`

## `npm run workflow:docs-sync`

- 解决问题：避免“改了运行时契约但没更新文档”。
- 为什么这样设计：文档和实现分离演化时，最容易产生隐性认知漂移。
- 关键检查（摘核心）：
  - 当 `scripts/`、adapter 配置、策略配置等触发文件变更时，
  - 要求本次变更同时包含配置中要求的文档文件（默认含 `docs/02-功能手册-命令原理与产物.md`、`docs/05-命令与产物速查表.md`、`docs/06-多项目类型接入与配置指南.md`）。
- 产物：
  - `.metrics/workflow-docs-sync-gate.md`
  - `.metrics/workflow-docs-sync-gate.json`

## 4. 指标门禁（Indicator Gate）

## `npm run metrics:collect`

- 解决问题：把流程质量数据化，避免“感觉上好像在进步”。
- 为什么这样设计：治理改进必须有量化依据。
- 数据来源：
  - 默认 `.metrics/verify-runs.jsonl`
  - 可由环境变量或参数改写路径
- 产物：
  - `.metrics/workflow-metrics-weekly.md`
  - `.metrics/workflow-metrics-latest.json`
- 指标覆盖：
  - 近 7 日成功率/失败率
  - lead time P50/P90
  - rework 数
  - 并行吞吐（active/archived）
  - spec drift 事件
  - token cost 状态

## `npm run workflow:gate`

- 解决问题：把指标阈值变成可执行门禁。
- 为什么这样设计：指标不是“看报告”，而是“可以阻止坏状态继续扩散”。
- 依赖输入：
  - `.metrics/workflow-metrics-latest.json`
- 阈值来源：
  - `workflow-policy.json -> indicatorGate`
- 产物：
  - `.metrics/workflow-indicator-gate.md`
  - `.metrics/workflow-indicator-gate.json`

## `npm run metrics:token-cost -- -Source <provider> -TotalCostUsd <amount>`

- 解决问题：跟踪 AI 成本，不把成本当黑盒。
- 产物：
  - `.metrics/token-cost.json`
- 备注：
  - indicator gate 是否强制 token cost，可在 `workflow-policy.json` 配置。

## 5. 一键健康诊断（Workflow Doctor）

## `npm run workflow:doctor`

- 解决问题：环境异常时，不知道先排哪一层。
- 为什么这样设计：先统一体检，再逐项修复，比盲跑快得多。
- 检查范围：
  - Node 版本
  - OpenSpec CLI 可用性
  - 关键路径存在性
  - active change 可读性
  - verify 遥测存在性
  - policy gate 健康
  - indicator gate 健康
- 产物：
  - `.metrics/workflow-doctor.md`
  - `.metrics/workflow-doctor.json`
- 返回语义：
  - 任一核心检查失败时命令非零退出。

## `npm run workflow:doctor:json`

- 作用：先跑 doctor，再直接打印 JSON 报告，便于脚本化消费。

## 6. 记忆治理与渐进披露

## `npm run memory:context -- -Stage index`

- 解决问题：AI 上下文一次注入过多导致噪声和成本上升。
- 为什么这样设计：先给“目录级索引”，再按需取细节。
- 输出：
  - 结构化 JSON，包含 `S001/S002...` 形式稳定 ID

## `npm run memory:context -- -Stage detail -Ids S001,S003`

- 作用：按 ID 精确取细节，不一次性拉满上下文。
- 产物：
  - 审计日志写入 `.metrics/memory-context-audit.jsonl`
- 分支兼容性：
  - 在非 `sbk-*` 分支也可工作（已做可用性修复）。

## 7. 可确定性重构（语义重命名）

## `npm run refactor:rename -- --file <path> --line <n> --column <n> --newName <name> [--dryRun]`

- 解决问题：文本替换重命名容易误改字符串/注释/同名无关符号。
- 为什么这样设计：通过 TypeScript Language Service 精确定位符号引用。
- 常用模式：
  - 先 `--dryRun` 预览影响面。
  - 再正式执行。
- 输出：
  - JSON 结构化结果（影响文件数、引用数、模式）。

## 8. 示例服务与可用性证明

## `npm run dev`

- 作用：启动 appdemo 服务（默认端口 3000，支持 `PORT` 覆盖）。

## `npm run demo:smoke`

- 作用：最小可用性冒烟验证。
- 行为：
  - 必要时先 build
  - 启动服务（端口 3210）
  - 依次验证：
    - `GET /health`
    - `POST /api/tasks`
    - `GET /api/tasks`
- 失败含义：
  - 任何关键链路异常即失败并退出。

## 9. 安全相关命令

## `npm run secret:scan`

- 扫描 staged 改动中的 secret 模式。

## `npm run secret:scan:diff`

- 扫描相对 `main` 的差异文件。

## `npm run secret:baseline`

- 更新基线文件 `.secrets.baseline`（用于降低误报）。

## 10. 常用组合

## `npm run sbk -- <subcommand>`

- 作用：通过统一入口调用 verify/policy/doctor/change/session 能力。
- 常见示例：
  - `npm run sbk -- verify:fast`
  - `npm run sbk -- policy`
  - `npm run sbk -- install --target-repo-root <target-repo-root> --preset minimal`
  - `npm run sbk -- upgrade --target-repo-root <target-repo-root> --preset full`
  - `npm run sbk -- greenfield --adapter node-ts --project-name demo-app --target-repo-root <target-repo-root>`
  - `npm run sbk -- flow run --target-repo-root <target-repo-root> --decision-mode auto`
  - `npm run sbk -- new-change <change-id>`
  - `npm run sbk -- docs-sync`

## `npm run sbk -- install --target-repo-root <path> --preset <minimal|full>`

- 作用：向目标仓库安装 SBK 内核文件与命令入口。
- 关键行为：
  - `minimal`：复制严格治理核心文件。
  - `full`：复制扩展运行时资产（脚本/配置/docs/spec/skills）。
  - 默认非覆盖安装（同名文件跳过）。
- 可选项：
  - `--overwrite`：开启覆盖写入。
  - `--skip-package-scripts`：跳过 `package.json` 脚本注入。

## `npm run sbk -- upgrade --target-repo-root <path> --preset <minimal|full>`

- 作用：覆盖刷新目标仓库已安装的 SBK 内核文件。
- 关键行为：
  - 升级命令内置覆盖模式（overwrite）。
  - 适合同步内核新版本脚本与策略变更。

## `npm run sbk -- greenfield --adapter <name> --project-name <name>`

- 作用：在 zero-to-one 场景初始化项目级产物和 adapter 对应的最小语言脚手架。
- 关键产物：
  - `PROJECT.md`
  - `REQUIREMENTS.md`
  - `ROADMAP.md`
  - `STATE.md`
  - `CONTEXT.md`
  - `.planning/research/.gitkeep`
- 行为约束：
  - 默认只创建缺失文件，不覆盖已有内容。
  - 使用 `--force` 时允许覆盖。
  - 使用 `--no-language-stubs` 时只初始化项目级产物，不生成语言脚手架。
- Trigger boundary: this command scaffolds planning artifacts and language stubs only. It does **not** implicitly run brainstorm/explore/new-change steps.

## 本地开发组合

```powershell
npm run verify:fast
npm run memory:context -- -Stage index
```

## 提交前组合

```powershell
npm run verify
npm run workflow:doctor
```

## 发布前组合

```powershell
npm run verify:ci
npm run demo:smoke
```

## 周期复盘组合

```powershell
npm run metrics:collect
npm run workflow:gate
npm run metrics:report:last
```

这就是本项目“功能正确性 + 可用性 + 可治理性”三条线并行落地的命令体系。

## sbk Advanced Workflow Commands

Use these subcommands through the unified entry:

- `npm run sbk -- explore --change <change-id> --include-apply-context`
- `npm run sbk -- improve-ut`
- `npm run sbk -- migrate-specs --change <change-id>`
- `npm run sbk -- migrate-specs --change <change-id> --apply`
- `npm run sbk -- migrate-specs --change <change-id> --apply --unsafe-overwrite` (only for explicit full overwrite)
- `npm run sbk -- parallel plan --name <task> --type <backend|frontend|fullstack> --requirement "<desc>" --platform codex`
- `npm run sbk -- parallel start <task-dir> --platform codex`
- `npm run sbk -- parallel status`

These commands keep Trellis workflows accessible without calling raw script paths directly.

`migrate-specs --apply` now performs merge-style sync against canonical specs by default, preserving untouched requirements and scenarios.

## Explicit vs Conditional Triggers

- Explicit triggers (must be invoked directly):
  - `/trellis:start`
  - `/trellis:record-session` or `npm run sbk -- record-session ...`
  - `npm run sbk -- explore --change <change-id>`
  - `npm run sbk -- new-change <change-id>`
  - `npm run sbk -- parallel <plan|start|status|cleanup> ...`
  - `npm run sbk -- migrate-specs --change <change-id> --apply`
  - high-risk switches: `npm run sbk -- flow run ... --force`, `npm run sbk -- flow run ... --allow-beta`, `npm run sbk -- migrate-specs ... --unsafe-overwrite`
- Conditional implicit stages (only under `flow run` conditions):
  - install stage only when `--with-install` is provided
  - greenfield stage only when resolved `scenario` is `greenfield`
  - beta assets are allowed when `--channel beta` (flow auto-enables allowBeta) or explicit `--allow-beta`
  - verify-fast stage is skipped when `--skip-verify` is provided
  - fleet stages run only when `--fleet-roots` is provided
  - blueprint apply may use force mode when `--force`, or when `--with-install`, or when target already has `.github/workflows/ci.yml`
  - non-git target repo can be initialized by flow (`git init`) before intake
  - in auto mode with no explicit profile, intake verify may fallback `strict -> balanced -> lite`
- Non-trigger clarification: `flow run` does not implicitly execute `explore`, `new-change`, or session record commands.

## `npm run sbk -- flow run --target-repo-root <path> --decision-mode <auto|ask>`

- 作用：一条命令执行**条件化**编排链路，而不是无条件串联所有阶段。
- 条件链路：
  - install：仅当传入 `--with-install`
  - greenfield bootstrap：仅当 `scenario=greenfield`
  - blueprint apply + verify：按 `blueprint` 决策结果执行；`--force` 或特定上下文下可能进入覆盖模式
  - beta 资产放开：`--channel beta` 自动放开，或显式传入 `--allow-beta`
  - intake analyze/plan/verify：默认执行；auto 模式可发生 profile fallback
  - adapter doctor：默认执行
  - verify fast：默认执行，可用 `--skip-verify` 跳过
  - fleet collect/report/doctor：仅当传入 `--fleet-roots`
- 运行时补充行为：
  - 目标目录不是 git 仓库时，flow 可能先执行 `git init` 后再进入 intake 阶段
- 关键节点：`scenario`、`adapter`、`profile`、`blueprint`、`channel`。
- 高风险显式开关：`--force`、`--allow-beta`、`migrate-specs --unsafe-overwrite`。
- 决策模式：
  - `auto`：自动决策关键节点（不等同于需求 brainstorm）。
  - `ask`：关键节点交互确认（不等同于需求 brainstorm）。
- 关键产物：
  - `<target>/.metrics/flow-run-report.json`
  - `<target>/.metrics/flow-run-report.md`

## `npm run sbk -- semantic reference-map --file <path> --line <n> --column <n>`

- 作用：输出符号引用映射（已启用，不再是占位操作）。
- 产物：
  - `<target>/.metrics/semantic-operation-report.json`
  - `<target>/.metrics/semantic-operation-audit.jsonl`

## `npm run sbk -- semantic safe-delete-candidates --file <path> --line <n> --column <n>`

- 作用：输出可安全删除候选分析（已启用，不再是占位操作）。
- 产物：
  - `<target>/.metrics/semantic-operation-report.json`
  - `<target>/.metrics/semantic-operation-audit.jsonl`
